/**
 * API for project 3d-inventory
 * Run CRUD od 3d-inventory data model.
 *
 * OpenAPI spec version: 1.0.5
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
} from '@angular/common/http'
import { CustomHttpUrlEncodingCodec } from '../encoder'

import { Observable } from 'rxjs'

import { Componentsresponses404 } from '../model/componentsresponses404'
import { Componentsresponses5XX } from '../model/componentsresponses5XX'
import { Device } from '../model/device'
import { Log } from '../model/log'

import { BASE_PATH, COLLECTION_FORMATS } from '../variables'
import { Configuration } from '../configuration'

@Injectable()
export class DefaultService {
  protected basePath = 'http://localhost:8080'
  public defaultHeaders = new HttpHeaders()
  public configuration = new Configuration()

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (basePath) {
      this.basePath = basePath
    }
    if (configuration) {
      this.configuration = configuration
      this.basePath = basePath || configuration.basePath || this.basePath
    }
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data'
    for (const consume of consumes) {
      if (form === consume) {
        return true
      }
    }
    return false
  }

  /**
   *
   * Devices attributes
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public attributesGet(
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<any>
  public attributesGet(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<any>>
  public attributesGet(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<any>>
  public attributesGet(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders

    // to determine the Accept header
    let httpHeaderAccepts: string[] = []
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts)
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = []

    return this.httpClient.request<any>('get', `${this.basePath}/attributes`, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress,
    })
  }

  /**
   * Server heartbeat operation. Get information about devices attributes types.
   * Dictionary attributes types of specific type of device.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public attributesTypesGET(
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<any>
  public attributesTypesGET(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<any>>
  public attributesTypesGET(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<any>>
  public attributesTypesGET(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders

    // to determine the Accept header
    let httpHeaderAccepts: string[] = []
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts)
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = []

    return this.httpClient.request<any>(
      'get',
      `${this.basePath}/attribute-dictionary`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Server heartbeat operation. Get information about connection between Devices.
   * Connection between devices
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public connectionsGET(
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<any>
  public connectionsGET(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<any>>
  public connectionsGET(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<any>>
  public connectionsGET(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders

    // to determine the Accept header
    let httpHeaderAccepts: string[] = []
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts)
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = []

    return this.httpClient.request<any>('get', `${this.basePath}/connections`, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress,
    })
  }

  /**
   * Delete device
   * Delete device.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deviceDELETE(
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<any>
  public deviceDELETE(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<any>>
  public deviceDELETE(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<any>>
  public deviceDELETE(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json']
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts)
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = []

    return this.httpClient.request<any>('delete', `${this.basePath}/device`, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress,
    })
  }

  /**
   * Get devices
   * Get list devices.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deviceGET(
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<Device>
  public deviceGET(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<Device>>
  public deviceGET(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<Device>>
  public deviceGET(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json']
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts)
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = []

    return this.httpClient.request<Device>('get', `${this.basePath}/device`, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress,
    })
  }

  /**
   * Create new device
   * Insert new device.
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public devicePOST(
    body?: Device,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<Device>
  public devicePOST(
    body?: Device,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<Device>>
  public devicePOST(
    body?: Device,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<Device>>
  public devicePOST(
    body?: Device,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json']
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts)
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    return this.httpClient.request<Device>('post', `${this.basePath}/device`, {
      body: body,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress,
    })
  }

  /**
   * Update device
   * Update existing device.
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public devicePUT(
    body?: Device,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<Device>
  public devicePUT(
    body?: Device,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<Device>>
  public devicePUT(
    body?: Device,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<Device>>
  public devicePUT(
    body?: Device,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json']
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts)
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    return this.httpClient.request<Device>('put', `${this.basePath}/device`, {
      body: body,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress,
    })
  }

  /**
   * Delete log
   * Delete all or specific id log.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public logDELETE(observe?: 'body', reportProgress?: boolean): Observable<any>
  public logDELETE(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<any>>
  public logDELETE(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<any>>
  public logDELETE(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json']
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts)
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = []

    return this.httpClient.request<any>('delete', `${this.basePath}/log`, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress,
    })
  }

  /**
   * Get log from database
   * Get all log.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public logGET(observe?: 'body', reportProgress?: boolean): Observable<Log>
  public logGET(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<Log>>
  public logGET(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<Log>>
  public logGET(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json']
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts)
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = []

    return this.httpClient.request<Log>('get', `${this.basePath}/log`, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress,
    })
  }

  /**
   * Insert new log
   * Create log.
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public logPOST(
    body: Log,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<Log>
  public logPOST(
    body: Log,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<Log>>
  public logPOST(
    body: Log,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<Log>>
  public logPOST(
    body: Log,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error(
        'Required parameter body was null or undefined when calling logPOST.'
      )
    }

    let headers = this.defaultHeaders

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json']
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts)
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    return this.httpClient.request<Log>('post', `${this.basePath}/log`, {
      body: body,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress,
    })
  }

  /**
   * Update new log
   * Update log record.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public logPUT(observe?: 'body', reportProgress?: boolean): Observable<Log>
  public logPUT(
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<Log>>
  public logPUT(
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<Log>>
  public logPUT(
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let headers = this.defaultHeaders

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['application/json']
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts)
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = []

    return this.httpClient.request<Log>('put', `${this.basePath}/log`, {
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress,
    })
  }
}
